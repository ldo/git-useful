#!/usr/bin/python3
#+
# This script generates a release archive from a Git repo commit. For
# repeatability, the timestamp and contents for each file are taken
# from the last commit at or before the specified one that affects
# that file.
#
# Invoke this script as follows:
#
#     make-snapshot [«options»] «basename» «commit» [«file»|«dir»...]
#
# where «basename» is the base output name of the archive to create,
# without the .zip extension, and «commit» is any valid reference to
# the Git commit from which to generate the snapshot. The name for the
# generated ZIP archive will be «basename»-«commit».zip, and the name
# of the top-level directory within the archive will be taken from the
# last component of «basename». The rest of the arguments specify the
# names of the files/directories to include in the archive. Directory
# names are recognized as ending with a slash; names that do not end
# with a slash are treated as filenames. Valid «options» are as follows:
#
#     -i «include-file»
#        alternative way of specifying the files/directories to
#        include in the archive. «include-file» is the name of a file
#        containing the names of the files/directories to include. The
#        entries in the file can be terminated by nulls or by newline
#        characters; in the latter case, the same escapes generated by
#        git-ls-tree (“\t” for tab, “\n” for newline, “\\” for
#        backslash) are recognized in the file/directory names.
#     -y
#        overwrite any existing output archive file. If not specified,
#        then an error is raised if the output file already exists.
#
# For example, the command
#
#     make-snapshot release v1.0 fred.py tools/
#
# will make an archive for the commit tagged “v1.0” (assuming it
# exists) under the name “release-v1.0.zip”, which contains “fred.py”
# and all the files under the “tools/” subdirectory. All items in the
# archive will have the prefix “release/” prefixed to their paths.
#
# Copyright 2020 by Lawrence D'Oliveiro <ldo@geek-central.gen.nz>.
# Licensed under CC-BY <http://creativecommons.org/licenses/by/4.0/>.
#-

import sys
import os
import time
import subprocess
import zipfile
import getopt

#+
# Useful stuff
#-

def git(*args) :
    # convenience routine for simplifying git command calls.
    return \
        subprocess.check_output(("git",) + args)
#end git

def unescape(s) :
    # unescapes “\t”, “\n” and “\\” sequences like those
    # generated by git-ls-tree.
    t = b""
    while True :
        pos = s.find(b"\\")
        if pos < 0 :
            t += s
            break
        #end if
        t += s[:pos]
        s = s[pos + 1:]
        if len(s) == 0 :
            raise RuntimeError("incomplete escape sequence: %s" % repr(t + s))
        #end if
        c = s[0]
        s = s[1:]
        if c == ord(b"t") :
            c = b"\011"
        elif c == ord(b"n") :
            c = b"\012"
        elif c == ord(b"\\") :
            c = b"\\"
        else :
            raise RuntimeError("unrecognized escape sequence: \\%s" % repr(c))
        #end if
        t += c
    #end while
    return t
#end unescape

overwrite = False
including = []
opts, args = getopt.getopt \
  (
    sys.argv[1:],
    "i:y",
    []
  )
for keyword, value in opts :
    if keyword == "-i" :
        data = open(value, "rb").read()
        if len(data) != 0 :
            pos = data.find(0)
            if pos >= 0 :
                assert data[-1] == 0, "last entry must end with null"
                entries = list(e for e in data.split(b"\0") if len(e) != 0)
            else :
                assert data[-1] == 0o012, "no newline after last line"
                entries = list(unescape(e) for e in data.split(b"\012") if len(e) != 0)
            #end if
            entries = list(e.decode() for e in entries)
            including.extend(entries)
        #end if
    elif keyword == "-y" :
        overwrite = True
    #end if
#end for
if len(args) < 2 :
    raise getopt.GetoptError("usage: %s «commit» «zipfilename» [«file»|«dir»...]")
#end if
outbasename, upto = args[:2]
including.extend(args[2:])
if len(including) == 0 :
    raise getopt.GetoptError("no files/dirs specified to include in archive")
#end if
if (
        any(i.startswith("/") for i in including)
    or
        any(".." in i or "." in i for f in including for i in (f.split("/"),))
) :
    raise getopt.GetoptError("all included items must have relative paths")
#nd if
earliest = git("rev-list", "--reverse", upto).split(b"\n")[0].strip().decode()

outfilename = "%s-%s.zip" % (outbasename, upto)
basename = os.path.split(outbasename)[1]
out = zipfile.ZipFile(outfilename, ("x", "w")[overwrite])

for entry in git("ls-tree", "-rz", upto).split(b"\0") :
    if entry != b"" :
        entry, filename = entry.decode().split("\t", 1)
        file_mode, kind, object_hash = entry.split(" ")
        assert kind == "blob" # no “tree” entries with -r
        file_mode = {"100644" : 0o100644, "100755" : 0o100755}[file_mode]
        if (
                filename in (e for e in including if not e.endswith("/"))
            or
                any(filename.startswith(e) for e in including if e.endswith("/"))
        ) :
            timestamp = \
                git("log", "--format=%ct", "-n1", "%s..%s" % (earliest, upto), "--", filename) \
                .strip()
            if timestamp == b"" :
                # only occurrence of filename is in first commit
                timestamp = \
                    git("log", "--format=%ct", "-n1", "--", filename) \
                    .strip()
            #end if
            timestamp = int(timestamp)
            item = zipfile.ZipInfo()
            item.filename = "/".join((basename, filename))
            item.compress_type = zipfile.ZIP_DEFLATED
            item.external_attr = file_mode << 16
            item.date_time = time.gmtime(timestamp)[:6]
            object_contents = git("show", object_hash)
            out.writestr(item, object_contents)
        #end if
    #end if
#end for
out.close()
sys.stdout.write("created archive %s\n" % outfilename)
