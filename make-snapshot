#!/usr/bin/python3
#+
# Generate a release archive from a repo commit. For repeatability,
# the timestamp and contents for each file are taken from the last
# commit affecting that file.
#
# This script takes an arg identifying a specific commit (e.g. a tag)
# from which to generate the archive, followed by a name for the
# output .zip file and then one or more names of files or directories
# from the repo to include. For example, the command
#
#     ./make-snapshot release v1.0 fred.py tools/
#
# will make an archive for the commit tagged “v1.0” (assuming it
# exists) under the name “release-v1.0.zip”, which contains “fred.py”
# and all the files under the “tools/” subdirectory. All items in the
# archive will have the prefix “release/” prefixed to their paths.
#
# Copyright 2020 by Lawrence D'Oliveiro <ldo@geek-central.gen.nz>.
# Licensed under CC-BY <http://creativecommons.org/licenses/by/4.0/>.
#-

import sys
import os
import time
import subprocess
import zipfile
import getopt

def git(*args) :
    # convenience routine for simplifying git command calls.
    return \
        subprocess.check_output(("git",) + args)
#end git

overwrite = False
opts, args = getopt.getopt \
  (
    sys.argv[1:],
    "y",
    []
  )
for keyword, value in opts :
    if keyword == "-y" :
        overwrite = True
    #end if
#end for
if len(args) < 3 :
    raise getopt.GetoptError("usage: %s «commit» «zipfilename» «file»|«dir»...")
#end if
outbasename, upto = args[:2]
including = args[2:]
if (
        any(i.startswith("/") for i in including)
    or
        any(".." in i or "." in i for f in including for i in (f.split("/"),))
) :
    raise getopt.GetoptError("all included items must have relative paths")
#nd if
earliest = git("rev-list", "--reverse", upto).split(b"\n")[0].strip().decode()

outfilename = "%s-%s.zip" % (outbasename, upto)
basename = os.path.split(outbasename)[1]
out = zipfile.ZipFile(outfilename, ("x", "w")[overwrite])

for entry in git("ls-tree", "-rz", upto).split(b"\0") :
    if entry != b"" :
        entry, filename = entry.decode().split("\t", 1)
        file_mode, kind, object_hash = entry.split(" ")
        assert kind == "blob" # no “tree” entries with -r
        file_mode = {"100644" : 0o100644, "100755" : 0o100755}[file_mode]
        if (
                filename in (e for e in including if not e.endswith("/"))
            or
                any(filename.startswith(e) for e in including if e.endswith("/"))
        ) :
            timestamp = \
                git("log", "--format=%ct", "-n1", "%s..%s" % (earliest, upto), "--", filename) \
                .strip()
            if timestamp == b"" :
                # only occurrence of filename is in first commit
                timestamp = \
                    git("log", "--format=%ct", "-n1", "--", filename) \
                    .strip()
            #end if
            timestamp = int(timestamp)
            item = zipfile.ZipInfo()
            item.filename = "/".join((basename, filename))
            item.compress_type = zipfile.ZIP_DEFLATED
            item.external_attr = file_mode << 16
            item.date_time = time.gmtime(timestamp)[:6]
            object_contents = git("show", object_hash)
            out.writestr(item, object_contents)
        #end if
    #end if
#end for
out.close()
sys.stdout.write("created archive %s\n" % outfilename)
